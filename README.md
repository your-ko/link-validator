[![Main](https://github.com/your-ko/link-validator/actions/workflows/main.yaml/badge.svg)](https://github.com/your-ko/link-validator/actions/workflows/main.yaml)
[![golangci-lint](https://github.com/your-ko/link-validator/actions/workflows/golangci-lint.yaml/badge.svg)](https://github.com/your-ko/link-validator/actions/workflows/golangci-lint.yaml)
[![Link validation](https://github.com/your-ko/link-validator/actions/workflows/workflow-link-validator.yaml/badge.svg)](https://github.com/your-ko/link-validator/actions/workflows/workflow-link-validator.yaml)

# About
Your project grows and it is time to write some documentation for it?

You already have written some documentation, added links to some modules declared in another repositories or links to 3rd party tools.
Then everything evolves, some repositories decommissioned, some 3rd party tools change their documentation.
And then in the middle of an accident you find yourself in a situation when your documentation is incomplete and some important links leads to nowhere?
Then this is the tool for you! It helps to early detect all broken links in your repository.

## WHat can it do
Link validator can check:
* all GitHub urls (to another repositories)
* links to another websites
* Markdown links to files inside the repository

## Usage
You add this GitHub workflow into your repository:
```yaml
name: Link validation
on:
  push:
    branches:
      - master
      - main

env:
  DOCKER_VALIDATOR: ghcr.io/your-ko/link-validator:0.18.0

jobs:
  link-validator:
    name: link-validator
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout
        uses: actions/checkout@v5.0.0

      - name: Run Link validation
        id: lnk
        env:
          LV_LOG_LEVEL: "info"
          LV_FILE_MASKS: "*.md"
          LV_PAT: ${{ secrets.GITHUB_TOKEN }}
          LV_CORP_PAT: ${{ secrets.GITHUB_TOKEN }}
          LV_CORP_URL: ""
        shell: bash
        run: |
          env | grep -E '^LV_' > .env
          docker run --rm \
            --env-file .env \
            -v "${{ github.workspace }}:/work" \
            -w /work \
            ${{env.DOCKER_VALIDATOR}}
```
The workflow file above is sufficient to run validator on your public GitHub repository.

## Configuration
### LV_LOG_LEVEL
Sets up the logging verbosity. Possible values are "debug", "info", "warn", "error".

Default: "info"

### LV_FILE_MASKS
Filemasks to validate. At this moment only markdown (*.md) files are fully supported. 

Default: *.md

### LV_PAT
Public GitHub PAT. Optional parameter. Setting this helps to avoid request throttling. 

### GHES
If you plan to run the validator on your Enterprise GitHub, then you need to set these two parameters:
#### LV_CORP_URL
URL of your enterprise GitHub. Used to access the other repositories in the enterprise domain, using enterprise PAT. 
#### LV_CORP_PAT
Enterprise GitHub PAT with the permission to read repositories. It is used to validate cross-repository URLs, 
for example when documentation of repository A references a code snippet from a repository B. 

## Under the hood
I use Go lang. That's why the main logic is packed into a docker image ghcr.io/your-ko/link-validator.
Docker image size is approximately 10Mb, so it won't create much traffic and it is quite fast to download. 

The PATs are used only to access cross-referenced repositories. 

The main validator at the moment consists of three validators:
* GitHub validator. It is responsible for validation of content, generated by GitHub API. 
* HTTP validator. It is responsible for validation of the other https urls.
* LocalPath validator. It validates only local markdown links, for example [here](./README.md) 

