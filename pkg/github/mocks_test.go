// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package github

import (
	"context"

	"github.com/google/go-github/v77/github"
	mock "github.com/stretchr/testify/mock"
)

// newMockclient creates a new instance of mockclient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockclient(t interface {
	mock.TestingT
	Cleanup(func())
}) *mockclient {
	mock := &mockclient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mockclient is an autogenerated mock type for the client type
type mockclient struct {
	mock.Mock
}

type mockclient_Expecter struct {
	mock *mock.Mock
}

func (_m *mockclient) EXPECT() *mockclient_Expecter {
	return &mockclient_Expecter{mock: &_m.Mock}
}

// compareCommits provides a mock function for the type mockclient
func (_mock *mockclient) compareCommits(ctx context.Context, owner string, repo string, base string, head string, opts *github.ListOptions) (*github.CommitsComparison, *github.Response, error) {
	ret := _mock.Called(ctx, owner, repo, base, head, opts)

	if len(ret) == 0 {
		panic("no return value specified for compareCommits")
	}

	var r0 *github.CommitsComparison
	var r1 *github.Response
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string, *github.ListOptions) (*github.CommitsComparison, *github.Response, error)); ok {
		return returnFunc(ctx, owner, repo, base, head, opts)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string, *github.ListOptions) *github.CommitsComparison); ok {
		r0 = returnFunc(ctx, owner, repo, base, head, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.CommitsComparison)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string, string, *github.ListOptions) *github.Response); ok {
		r1 = returnFunc(ctx, owner, repo, base, head, opts)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, string, string, string, *github.ListOptions) error); ok {
		r2 = returnFunc(ctx, owner, repo, base, head, opts)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// mockclient_compareCommits_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'compareCommits'
type mockclient_compareCommits_Call struct {
	*mock.Call
}

// compareCommits is a helper method to define mock.On call
//   - ctx context.Context
//   - owner string
//   - repo string
//   - base string
//   - head string
//   - opts *github.ListOptions
func (_e *mockclient_Expecter) compareCommits(ctx interface{}, owner interface{}, repo interface{}, base interface{}, head interface{}, opts interface{}) *mockclient_compareCommits_Call {
	return &mockclient_compareCommits_Call{Call: _e.mock.On("compareCommits", ctx, owner, repo, base, head, opts)}
}

func (_c *mockclient_compareCommits_Call) Run(run func(ctx context.Context, owner string, repo string, base string, head string, opts *github.ListOptions)) *mockclient_compareCommits_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		var arg5 *github.ListOptions
		if args[5] != nil {
			arg5 = args[5].(*github.ListOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *mockclient_compareCommits_Call) Return(commitsComparison *github.CommitsComparison, response *github.Response, err error) *mockclient_compareCommits_Call {
	_c.Call.Return(commitsComparison, response, err)
	return _c
}

func (_c *mockclient_compareCommits_Call) RunAndReturn(run func(ctx context.Context, owner string, repo string, base string, head string, opts *github.ListOptions) (*github.CommitsComparison, *github.Response, error)) *mockclient_compareCommits_Call {
	_c.Call.Return(run)
	return _c
}

// getCommit provides a mock function for the type mockclient
func (_mock *mockclient) getCommit(ctx context.Context, owner string, repo string, sha string, opts *github.ListOptions) (*github.RepositoryCommit, *github.Response, error) {
	ret := _mock.Called(ctx, owner, repo, sha, opts)

	if len(ret) == 0 {
		panic("no return value specified for getCommit")
	}

	var r0 *github.RepositoryCommit
	var r1 *github.Response
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, *github.ListOptions) (*github.RepositoryCommit, *github.Response, error)); ok {
		return returnFunc(ctx, owner, repo, sha, opts)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, *github.ListOptions) *github.RepositoryCommit); ok {
		r0 = returnFunc(ctx, owner, repo, sha, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.RepositoryCommit)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string, *github.ListOptions) *github.Response); ok {
		r1 = returnFunc(ctx, owner, repo, sha, opts)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, string, string, *github.ListOptions) error); ok {
		r2 = returnFunc(ctx, owner, repo, sha, opts)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// mockclient_getCommit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'getCommit'
type mockclient_getCommit_Call struct {
	*mock.Call
}

// getCommit is a helper method to define mock.On call
//   - ctx context.Context
//   - owner string
//   - repo string
//   - sha string
//   - opts *github.ListOptions
func (_e *mockclient_Expecter) getCommit(ctx interface{}, owner interface{}, repo interface{}, sha interface{}, opts interface{}) *mockclient_getCommit_Call {
	return &mockclient_getCommit_Call{Call: _e.mock.On("getCommit", ctx, owner, repo, sha, opts)}
}

func (_c *mockclient_getCommit_Call) Run(run func(ctx context.Context, owner string, repo string, sha string, opts *github.ListOptions)) *mockclient_getCommit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 *github.ListOptions
		if args[4] != nil {
			arg4 = args[4].(*github.ListOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *mockclient_getCommit_Call) Return(repositoryCommit *github.RepositoryCommit, response *github.Response, err error) *mockclient_getCommit_Call {
	_c.Call.Return(repositoryCommit, response, err)
	return _c
}

func (_c *mockclient_getCommit_Call) RunAndReturn(run func(ctx context.Context, owner string, repo string, sha string, opts *github.ListOptions) (*github.RepositoryCommit, *github.Response, error)) *mockclient_getCommit_Call {
	_c.Call.Return(run)
	return _c
}

// getContents provides a mock function for the type mockclient
func (_mock *mockclient) getContents(ctx context.Context, owner string, repo string, ref string, path string) (*github.RepositoryContent, []*github.RepositoryContent, *github.Response, error) {
	ret := _mock.Called(ctx, owner, repo, ref, path)

	if len(ret) == 0 {
		panic("no return value specified for getContents")
	}

	var r0 *github.RepositoryContent
	var r1 []*github.RepositoryContent
	var r2 *github.Response
	var r3 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string) (*github.RepositoryContent, []*github.RepositoryContent, *github.Response, error)); ok {
		return returnFunc(ctx, owner, repo, ref, path)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string) *github.RepositoryContent); ok {
		r0 = returnFunc(ctx, owner, repo, ref, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.RepositoryContent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string, string) []*github.RepositoryContent); ok {
		r1 = returnFunc(ctx, owner, repo, ref, path)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]*github.RepositoryContent)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, string, string, string) *github.Response); ok {
		r2 = returnFunc(ctx, owner, repo, ref, path)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).(*github.Response)
		}
	}
	if returnFunc, ok := ret.Get(3).(func(context.Context, string, string, string, string) error); ok {
		r3 = returnFunc(ctx, owner, repo, ref, path)
	} else {
		r3 = ret.Error(3)
	}
	return r0, r1, r2, r3
}

// mockclient_getContents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'getContents'
type mockclient_getContents_Call struct {
	*mock.Call
}

// getContents is a helper method to define mock.On call
//   - ctx context.Context
//   - owner string
//   - repo string
//   - ref string
//   - path string
func (_e *mockclient_Expecter) getContents(ctx interface{}, owner interface{}, repo interface{}, ref interface{}, path interface{}) *mockclient_getContents_Call {
	return &mockclient_getContents_Call{Call: _e.mock.On("getContents", ctx, owner, repo, ref, path)}
}

func (_c *mockclient_getContents_Call) Run(run func(ctx context.Context, owner string, repo string, ref string, path string)) *mockclient_getContents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *mockclient_getContents_Call) Return(repositoryContent *github.RepositoryContent, repositoryContents []*github.RepositoryContent, response *github.Response, err error) *mockclient_getContents_Call {
	_c.Call.Return(repositoryContent, repositoryContents, response, err)
	return _c
}

func (_c *mockclient_getContents_Call) RunAndReturn(run func(ctx context.Context, owner string, repo string, ref string, path string) (*github.RepositoryContent, []*github.RepositoryContent, *github.Response, error)) *mockclient_getContents_Call {
	_c.Call.Return(run)
	return _c
}

// getIssue provides a mock function for the type mockclient
func (_mock *mockclient) getIssue(ctx context.Context, owner string, repo string, number int) (*github.Issue, *github.Response, error) {
	ret := _mock.Called(ctx, owner, repo, number)

	if len(ret) == 0 {
		panic("no return value specified for getIssue")
	}

	var r0 *github.Issue
	var r1 *github.Response
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, int) (*github.Issue, *github.Response, error)); ok {
		return returnFunc(ctx, owner, repo, number)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, int) *github.Issue); ok {
		r0 = returnFunc(ctx, owner, repo, number)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.Issue)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, int) *github.Response); ok {
		r1 = returnFunc(ctx, owner, repo, number)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, string, int) error); ok {
		r2 = returnFunc(ctx, owner, repo, number)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// mockclient_getIssue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'getIssue'
type mockclient_getIssue_Call struct {
	*mock.Call
}

// getIssue is a helper method to define mock.On call
//   - ctx context.Context
//   - owner string
//   - repo string
//   - number int
func (_e *mockclient_Expecter) getIssue(ctx interface{}, owner interface{}, repo interface{}, number interface{}) *mockclient_getIssue_Call {
	return &mockclient_getIssue_Call{Call: _e.mock.On("getIssue", ctx, owner, repo, number)}
}

func (_c *mockclient_getIssue_Call) Run(run func(ctx context.Context, owner string, repo string, number int)) *mockclient_getIssue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *mockclient_getIssue_Call) Return(issue *github.Issue, response *github.Response, err error) *mockclient_getIssue_Call {
	_c.Call.Return(issue, response, err)
	return _c
}

func (_c *mockclient_getIssue_Call) RunAndReturn(run func(ctx context.Context, owner string, repo string, number int) (*github.Issue, *github.Response, error)) *mockclient_getIssue_Call {
	_c.Call.Return(run)
	return _c
}

// getIssueComment provides a mock function for the type mockclient
func (_mock *mockclient) getIssueComment(ctx context.Context, owner string, repo string, commentID int64) (*github.IssueComment, *github.Response, error) {
	ret := _mock.Called(ctx, owner, repo, commentID)

	if len(ret) == 0 {
		panic("no return value specified for getIssueComment")
	}

	var r0 *github.IssueComment
	var r1 *github.Response
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, int64) (*github.IssueComment, *github.Response, error)); ok {
		return returnFunc(ctx, owner, repo, commentID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, int64) *github.IssueComment); ok {
		r0 = returnFunc(ctx, owner, repo, commentID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.IssueComment)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, int64) *github.Response); ok {
		r1 = returnFunc(ctx, owner, repo, commentID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, string, int64) error); ok {
		r2 = returnFunc(ctx, owner, repo, commentID)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// mockclient_getIssueComment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'getIssueComment'
type mockclient_getIssueComment_Call struct {
	*mock.Call
}

// getIssueComment is a helper method to define mock.On call
//   - ctx context.Context
//   - owner string
//   - repo string
//   - commentID int64
func (_e *mockclient_Expecter) getIssueComment(ctx interface{}, owner interface{}, repo interface{}, commentID interface{}) *mockclient_getIssueComment_Call {
	return &mockclient_getIssueComment_Call{Call: _e.mock.On("getIssueComment", ctx, owner, repo, commentID)}
}

func (_c *mockclient_getIssueComment_Call) Run(run func(ctx context.Context, owner string, repo string, commentID int64)) *mockclient_getIssueComment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int64
		if args[3] != nil {
			arg3 = args[3].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *mockclient_getIssueComment_Call) Return(issueComment *github.IssueComment, response *github.Response, err error) *mockclient_getIssueComment_Call {
	_c.Call.Return(issueComment, response, err)
	return _c
}

func (_c *mockclient_getIssueComment_Call) RunAndReturn(run func(ctx context.Context, owner string, repo string, commentID int64) (*github.IssueComment, *github.Response, error)) *mockclient_getIssueComment_Call {
	_c.Call.Return(run)
	return _c
}

// getLatestRelease provides a mock function for the type mockclient
func (_mock *mockclient) getLatestRelease(ctx context.Context, owner string, repo string) (*github.RepositoryRelease, *github.Response, error) {
	ret := _mock.Called(ctx, owner, repo)

	if len(ret) == 0 {
		panic("no return value specified for getLatestRelease")
	}

	var r0 *github.RepositoryRelease
	var r1 *github.Response
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (*github.RepositoryRelease, *github.Response, error)); ok {
		return returnFunc(ctx, owner, repo)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) *github.RepositoryRelease); ok {
		r0 = returnFunc(ctx, owner, repo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.RepositoryRelease)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) *github.Response); ok {
		r1 = returnFunc(ctx, owner, repo)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, string) error); ok {
		r2 = returnFunc(ctx, owner, repo)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// mockclient_getLatestRelease_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'getLatestRelease'
type mockclient_getLatestRelease_Call struct {
	*mock.Call
}

// getLatestRelease is a helper method to define mock.On call
//   - ctx context.Context
//   - owner string
//   - repo string
func (_e *mockclient_Expecter) getLatestRelease(ctx interface{}, owner interface{}, repo interface{}) *mockclient_getLatestRelease_Call {
	return &mockclient_getLatestRelease_Call{Call: _e.mock.On("getLatestRelease", ctx, owner, repo)}
}

func (_c *mockclient_getLatestRelease_Call) Run(run func(ctx context.Context, owner string, repo string)) *mockclient_getLatestRelease_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *mockclient_getLatestRelease_Call) Return(repositoryRelease *github.RepositoryRelease, response *github.Response, err error) *mockclient_getLatestRelease_Call {
	_c.Call.Return(repositoryRelease, response, err)
	return _c
}

func (_c *mockclient_getLatestRelease_Call) RunAndReturn(run func(ctx context.Context, owner string, repo string) (*github.RepositoryRelease, *github.Response, error)) *mockclient_getLatestRelease_Call {
	_c.Call.Return(run)
	return _c
}

// getMilestone provides a mock function for the type mockclient
func (_mock *mockclient) getMilestone(ctx context.Context, owner string, repo string, number int) (*github.Milestone, *github.Response, error) {
	ret := _mock.Called(ctx, owner, repo, number)

	if len(ret) == 0 {
		panic("no return value specified for getMilestone")
	}

	var r0 *github.Milestone
	var r1 *github.Response
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, int) (*github.Milestone, *github.Response, error)); ok {
		return returnFunc(ctx, owner, repo, number)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, int) *github.Milestone); ok {
		r0 = returnFunc(ctx, owner, repo, number)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.Milestone)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, int) *github.Response); ok {
		r1 = returnFunc(ctx, owner, repo, number)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, string, int) error); ok {
		r2 = returnFunc(ctx, owner, repo, number)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// mockclient_getMilestone_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'getMilestone'
type mockclient_getMilestone_Call struct {
	*mock.Call
}

// getMilestone is a helper method to define mock.On call
//   - ctx context.Context
//   - owner string
//   - repo string
//   - number int
func (_e *mockclient_Expecter) getMilestone(ctx interface{}, owner interface{}, repo interface{}, number interface{}) *mockclient_getMilestone_Call {
	return &mockclient_getMilestone_Call{Call: _e.mock.On("getMilestone", ctx, owner, repo, number)}
}

func (_c *mockclient_getMilestone_Call) Run(run func(ctx context.Context, owner string, repo string, number int)) *mockclient_getMilestone_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *mockclient_getMilestone_Call) Return(milestone *github.Milestone, response *github.Response, err error) *mockclient_getMilestone_Call {
	_c.Call.Return(milestone, response, err)
	return _c
}

func (_c *mockclient_getMilestone_Call) RunAndReturn(run func(ctx context.Context, owner string, repo string, number int) (*github.Milestone, *github.Response, error)) *mockclient_getMilestone_Call {
	_c.Call.Return(run)
	return _c
}

// getOrganization provides a mock function for the type mockclient
func (_mock *mockclient) getOrganization(ctx context.Context, org string) (*github.Organization, *github.Response, error) {
	ret := _mock.Called(ctx, org)

	if len(ret) == 0 {
		panic("no return value specified for getOrganization")
	}

	var r0 *github.Organization
	var r1 *github.Response
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*github.Organization, *github.Response, error)); ok {
		return returnFunc(ctx, org)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *github.Organization); ok {
		r0 = returnFunc(ctx, org)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.Organization)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) *github.Response); ok {
		r1 = returnFunc(ctx, org)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string) error); ok {
		r2 = returnFunc(ctx, org)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// mockclient_getOrganization_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'getOrganization'
type mockclient_getOrganization_Call struct {
	*mock.Call
}

// getOrganization is a helper method to define mock.On call
//   - ctx context.Context
//   - org string
func (_e *mockclient_Expecter) getOrganization(ctx interface{}, org interface{}) *mockclient_getOrganization_Call {
	return &mockclient_getOrganization_Call{Call: _e.mock.On("getOrganization", ctx, org)}
}

func (_c *mockclient_getOrganization_Call) Run(run func(ctx context.Context, org string)) *mockclient_getOrganization_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mockclient_getOrganization_Call) Return(organization *github.Organization, response *github.Response, err error) *mockclient_getOrganization_Call {
	_c.Call.Return(organization, response, err)
	return _c
}

func (_c *mockclient_getOrganization_Call) RunAndReturn(run func(ctx context.Context, org string) (*github.Organization, *github.Response, error)) *mockclient_getOrganization_Call {
	_c.Call.Return(run)
	return _c
}

// getPR provides a mock function for the type mockclient
func (_mock *mockclient) getPR(ctx context.Context, owner string, repo string, number int) (*github.PullRequest, *github.Response, error) {
	ret := _mock.Called(ctx, owner, repo, number)

	if len(ret) == 0 {
		panic("no return value specified for getPR")
	}

	var r0 *github.PullRequest
	var r1 *github.Response
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, int) (*github.PullRequest, *github.Response, error)); ok {
		return returnFunc(ctx, owner, repo, number)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, int) *github.PullRequest); ok {
		r0 = returnFunc(ctx, owner, repo, number)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.PullRequest)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, int) *github.Response); ok {
		r1 = returnFunc(ctx, owner, repo, number)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, string, int) error); ok {
		r2 = returnFunc(ctx, owner, repo, number)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// mockclient_getPR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'getPR'
type mockclient_getPR_Call struct {
	*mock.Call
}

// getPR is a helper method to define mock.On call
//   - ctx context.Context
//   - owner string
//   - repo string
//   - number int
func (_e *mockclient_Expecter) getPR(ctx interface{}, owner interface{}, repo interface{}, number interface{}) *mockclient_getPR_Call {
	return &mockclient_getPR_Call{Call: _e.mock.On("getPR", ctx, owner, repo, number)}
}

func (_c *mockclient_getPR_Call) Run(run func(ctx context.Context, owner string, repo string, number int)) *mockclient_getPR_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *mockclient_getPR_Call) Return(pullRequest *github.PullRequest, response *github.Response, err error) *mockclient_getPR_Call {
	_c.Call.Return(pullRequest, response, err)
	return _c
}

func (_c *mockclient_getPR_Call) RunAndReturn(run func(ctx context.Context, owner string, repo string, number int) (*github.PullRequest, *github.Response, error)) *mockclient_getPR_Call {
	_c.Call.Return(run)
	return _c
}

// getPRComment provides a mock function for the type mockclient
func (_mock *mockclient) getPRComment(ctx context.Context, owner string, repo string, commentID int64) (*github.PullRequestComment, *github.Response, error) {
	ret := _mock.Called(ctx, owner, repo, commentID)

	if len(ret) == 0 {
		panic("no return value specified for getPRComment")
	}

	var r0 *github.PullRequestComment
	var r1 *github.Response
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, int64) (*github.PullRequestComment, *github.Response, error)); ok {
		return returnFunc(ctx, owner, repo, commentID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, int64) *github.PullRequestComment); ok {
		r0 = returnFunc(ctx, owner, repo, commentID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.PullRequestComment)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, int64) *github.Response); ok {
		r1 = returnFunc(ctx, owner, repo, commentID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, string, int64) error); ok {
		r2 = returnFunc(ctx, owner, repo, commentID)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// mockclient_getPRComment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'getPRComment'
type mockclient_getPRComment_Call struct {
	*mock.Call
}

// getPRComment is a helper method to define mock.On call
//   - ctx context.Context
//   - owner string
//   - repo string
//   - commentID int64
func (_e *mockclient_Expecter) getPRComment(ctx interface{}, owner interface{}, repo interface{}, commentID interface{}) *mockclient_getPRComment_Call {
	return &mockclient_getPRComment_Call{Call: _e.mock.On("getPRComment", ctx, owner, repo, commentID)}
}

func (_c *mockclient_getPRComment_Call) Run(run func(ctx context.Context, owner string, repo string, commentID int64)) *mockclient_getPRComment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int64
		if args[3] != nil {
			arg3 = args[3].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *mockclient_getPRComment_Call) Return(pullRequestComment *github.PullRequestComment, response *github.Response, err error) *mockclient_getPRComment_Call {
	_c.Call.Return(pullRequestComment, response, err)
	return _c
}

func (_c *mockclient_getPRComment_Call) RunAndReturn(run func(ctx context.Context, owner string, repo string, commentID int64) (*github.PullRequestComment, *github.Response, error)) *mockclient_getPRComment_Call {
	_c.Call.Return(run)
	return _c
}

// getReleaseByTag provides a mock function for the type mockclient
func (_mock *mockclient) getReleaseByTag(ctx context.Context, owner string, repo string, tag string) (*github.RepositoryRelease, *github.Response, error) {
	ret := _mock.Called(ctx, owner, repo, tag)

	if len(ret) == 0 {
		panic("no return value specified for getReleaseByTag")
	}

	var r0 *github.RepositoryRelease
	var r1 *github.Response
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) (*github.RepositoryRelease, *github.Response, error)); ok {
		return returnFunc(ctx, owner, repo, tag)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) *github.RepositoryRelease); ok {
		r0 = returnFunc(ctx, owner, repo, tag)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.RepositoryRelease)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string) *github.Response); ok {
		r1 = returnFunc(ctx, owner, repo, tag)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, string, string) error); ok {
		r2 = returnFunc(ctx, owner, repo, tag)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// mockclient_getReleaseByTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'getReleaseByTag'
type mockclient_getReleaseByTag_Call struct {
	*mock.Call
}

// getReleaseByTag is a helper method to define mock.On call
//   - ctx context.Context
//   - owner string
//   - repo string
//   - tag string
func (_e *mockclient_Expecter) getReleaseByTag(ctx interface{}, owner interface{}, repo interface{}, tag interface{}) *mockclient_getReleaseByTag_Call {
	return &mockclient_getReleaseByTag_Call{Call: _e.mock.On("getReleaseByTag", ctx, owner, repo, tag)}
}

func (_c *mockclient_getReleaseByTag_Call) Run(run func(ctx context.Context, owner string, repo string, tag string)) *mockclient_getReleaseByTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *mockclient_getReleaseByTag_Call) Return(repositoryRelease *github.RepositoryRelease, response *github.Response, err error) *mockclient_getReleaseByTag_Call {
	_c.Call.Return(repositoryRelease, response, err)
	return _c
}

func (_c *mockclient_getReleaseByTag_Call) RunAndReturn(run func(ctx context.Context, owner string, repo string, tag string) (*github.RepositoryRelease, *github.Response, error)) *mockclient_getReleaseByTag_Call {
	_c.Call.Return(run)
	return _c
}

// getRepository provides a mock function for the type mockclient
func (_mock *mockclient) getRepository(ctx context.Context, owner string, repo string) (*github.Repository, *github.Response, error) {
	ret := _mock.Called(ctx, owner, repo)

	if len(ret) == 0 {
		panic("no return value specified for getRepository")
	}

	var r0 *github.Repository
	var r1 *github.Response
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (*github.Repository, *github.Response, error)); ok {
		return returnFunc(ctx, owner, repo)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) *github.Repository); ok {
		r0 = returnFunc(ctx, owner, repo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.Repository)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) *github.Response); ok {
		r1 = returnFunc(ctx, owner, repo)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, string) error); ok {
		r2 = returnFunc(ctx, owner, repo)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// mockclient_getRepository_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'getRepository'
type mockclient_getRepository_Call struct {
	*mock.Call
}

// getRepository is a helper method to define mock.On call
//   - ctx context.Context
//   - owner string
//   - repo string
func (_e *mockclient_Expecter) getRepository(ctx interface{}, owner interface{}, repo interface{}) *mockclient_getRepository_Call {
	return &mockclient_getRepository_Call{Call: _e.mock.On("getRepository", ctx, owner, repo)}
}

func (_c *mockclient_getRepository_Call) Run(run func(ctx context.Context, owner string, repo string)) *mockclient_getRepository_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *mockclient_getRepository_Call) Return(repository *github.Repository, response *github.Response, err error) *mockclient_getRepository_Call {
	_c.Call.Return(repository, response, err)
	return _c
}

func (_c *mockclient_getRepository_Call) RunAndReturn(run func(ctx context.Context, owner string, repo string) (*github.Repository, *github.Response, error)) *mockclient_getRepository_Call {
	_c.Call.Return(run)
	return _c
}

// getUsers provides a mock function for the type mockclient
func (_mock *mockclient) getUsers(ctx context.Context, user string) (*github.User, *github.Response, error) {
	ret := _mock.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for getUsers")
	}

	var r0 *github.User
	var r1 *github.Response
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*github.User, *github.Response, error)); ok {
		return returnFunc(ctx, user)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *github.User); ok {
		r0 = returnFunc(ctx, user)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) *github.Response); ok {
		r1 = returnFunc(ctx, user)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string) error); ok {
		r2 = returnFunc(ctx, user)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// mockclient_getUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'getUsers'
type mockclient_getUsers_Call struct {
	*mock.Call
}

// getUsers is a helper method to define mock.On call
//   - ctx context.Context
//   - user string
func (_e *mockclient_Expecter) getUsers(ctx interface{}, user interface{}) *mockclient_getUsers_Call {
	return &mockclient_getUsers_Call{Call: _e.mock.On("getUsers", ctx, user)}
}

func (_c *mockclient_getUsers_Call) Run(run func(ctx context.Context, user string)) *mockclient_getUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *mockclient_getUsers_Call) Return(user1 *github.User, response *github.Response, err error) *mockclient_getUsers_Call {
	_c.Call.Return(user1, response, err)
	return _c
}

func (_c *mockclient_getUsers_Call) RunAndReturn(run func(ctx context.Context, user string) (*github.User, *github.Response, error)) *mockclient_getUsers_Call {
	_c.Call.Return(run)
	return _c
}

// getWorkflowByFileName provides a mock function for the type mockclient
func (_mock *mockclient) getWorkflowByFileName(ctx context.Context, owner string, repo string, workflowFileName string) (*github.Workflow, *github.Response, error) {
	ret := _mock.Called(ctx, owner, repo, workflowFileName)

	if len(ret) == 0 {
		panic("no return value specified for getWorkflowByFileName")
	}

	var r0 *github.Workflow
	var r1 *github.Response
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) (*github.Workflow, *github.Response, error)); ok {
		return returnFunc(ctx, owner, repo, workflowFileName)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) *github.Workflow); ok {
		r0 = returnFunc(ctx, owner, repo, workflowFileName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.Workflow)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string) *github.Response); ok {
		r1 = returnFunc(ctx, owner, repo, workflowFileName)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, string, string) error); ok {
		r2 = returnFunc(ctx, owner, repo, workflowFileName)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// mockclient_getWorkflowByFileName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'getWorkflowByFileName'
type mockclient_getWorkflowByFileName_Call struct {
	*mock.Call
}

// getWorkflowByFileName is a helper method to define mock.On call
//   - ctx context.Context
//   - owner string
//   - repo string
//   - workflowFileName string
func (_e *mockclient_Expecter) getWorkflowByFileName(ctx interface{}, owner interface{}, repo interface{}, workflowFileName interface{}) *mockclient_getWorkflowByFileName_Call {
	return &mockclient_getWorkflowByFileName_Call{Call: _e.mock.On("getWorkflowByFileName", ctx, owner, repo, workflowFileName)}
}

func (_c *mockclient_getWorkflowByFileName_Call) Run(run func(ctx context.Context, owner string, repo string, workflowFileName string)) *mockclient_getWorkflowByFileName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *mockclient_getWorkflowByFileName_Call) Return(workflow *github.Workflow, response *github.Response, err error) *mockclient_getWorkflowByFileName_Call {
	_c.Call.Return(workflow, response, err)
	return _c
}

func (_c *mockclient_getWorkflowByFileName_Call) RunAndReturn(run func(ctx context.Context, owner string, repo string, workflowFileName string) (*github.Workflow, *github.Response, error)) *mockclient_getWorkflowByFileName_Call {
	_c.Call.Return(run)
	return _c
}

// getWorkflowJobByID provides a mock function for the type mockclient
func (_mock *mockclient) getWorkflowJobByID(ctx context.Context, owner string, repo string, jobID int64) (*github.WorkflowJob, *github.Response, error) {
	ret := _mock.Called(ctx, owner, repo, jobID)

	if len(ret) == 0 {
		panic("no return value specified for getWorkflowJobByID")
	}

	var r0 *github.WorkflowJob
	var r1 *github.Response
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, int64) (*github.WorkflowJob, *github.Response, error)); ok {
		return returnFunc(ctx, owner, repo, jobID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, int64) *github.WorkflowJob); ok {
		r0 = returnFunc(ctx, owner, repo, jobID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.WorkflowJob)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, int64) *github.Response); ok {
		r1 = returnFunc(ctx, owner, repo, jobID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, string, int64) error); ok {
		r2 = returnFunc(ctx, owner, repo, jobID)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// mockclient_getWorkflowJobByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'getWorkflowJobByID'
type mockclient_getWorkflowJobByID_Call struct {
	*mock.Call
}

// getWorkflowJobByID is a helper method to define mock.On call
//   - ctx context.Context
//   - owner string
//   - repo string
//   - jobID int64
func (_e *mockclient_Expecter) getWorkflowJobByID(ctx interface{}, owner interface{}, repo interface{}, jobID interface{}) *mockclient_getWorkflowJobByID_Call {
	return &mockclient_getWorkflowJobByID_Call{Call: _e.mock.On("getWorkflowJobByID", ctx, owner, repo, jobID)}
}

func (_c *mockclient_getWorkflowJobByID_Call) Run(run func(ctx context.Context, owner string, repo string, jobID int64)) *mockclient_getWorkflowJobByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int64
		if args[3] != nil {
			arg3 = args[3].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *mockclient_getWorkflowJobByID_Call) Return(workflowJob *github.WorkflowJob, response *github.Response, err error) *mockclient_getWorkflowJobByID_Call {
	_c.Call.Return(workflowJob, response, err)
	return _c
}

func (_c *mockclient_getWorkflowJobByID_Call) RunAndReturn(run func(ctx context.Context, owner string, repo string, jobID int64) (*github.WorkflowJob, *github.Response, error)) *mockclient_getWorkflowJobByID_Call {
	_c.Call.Return(run)
	return _c
}

// getWorkflowRunByID provides a mock function for the type mockclient
func (_mock *mockclient) getWorkflowRunByID(ctx context.Context, owner string, repo string, runID int64) (*github.WorkflowRun, *github.Response, error) {
	ret := _mock.Called(ctx, owner, repo, runID)

	if len(ret) == 0 {
		panic("no return value specified for getWorkflowRunByID")
	}

	var r0 *github.WorkflowRun
	var r1 *github.Response
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, int64) (*github.WorkflowRun, *github.Response, error)); ok {
		return returnFunc(ctx, owner, repo, runID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, int64) *github.WorkflowRun); ok {
		r0 = returnFunc(ctx, owner, repo, runID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.WorkflowRun)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, int64) *github.Response); ok {
		r1 = returnFunc(ctx, owner, repo, runID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, string, int64) error); ok {
		r2 = returnFunc(ctx, owner, repo, runID)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// mockclient_getWorkflowRunByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'getWorkflowRunByID'
type mockclient_getWorkflowRunByID_Call struct {
	*mock.Call
}

// getWorkflowRunByID is a helper method to define mock.On call
//   - ctx context.Context
//   - owner string
//   - repo string
//   - runID int64
func (_e *mockclient_Expecter) getWorkflowRunByID(ctx interface{}, owner interface{}, repo interface{}, runID interface{}) *mockclient_getWorkflowRunByID_Call {
	return &mockclient_getWorkflowRunByID_Call{Call: _e.mock.On("getWorkflowRunByID", ctx, owner, repo, runID)}
}

func (_c *mockclient_getWorkflowRunByID_Call) Run(run func(ctx context.Context, owner string, repo string, runID int64)) *mockclient_getWorkflowRunByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int64
		if args[3] != nil {
			arg3 = args[3].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *mockclient_getWorkflowRunByID_Call) Return(workflowRun *github.WorkflowRun, response *github.Response, err error) *mockclient_getWorkflowRunByID_Call {
	_c.Call.Return(workflowRun, response, err)
	return _c
}

func (_c *mockclient_getWorkflowRunByID_Call) RunAndReturn(run func(ctx context.Context, owner string, repo string, runID int64) (*github.WorkflowRun, *github.Response, error)) *mockclient_getWorkflowRunByID_Call {
	_c.Call.Return(run)
	return _c
}

// listCommits provides a mock function for the type mockclient
func (_mock *mockclient) listCommits(ctx context.Context, owner string, repo string, number int, opts *github.ListOptions) ([]*github.RepositoryCommit, *github.Response, error) {
	ret := _mock.Called(ctx, owner, repo, number, opts)

	if len(ret) == 0 {
		panic("no return value specified for listCommits")
	}

	var r0 []*github.RepositoryCommit
	var r1 *github.Response
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, int, *github.ListOptions) ([]*github.RepositoryCommit, *github.Response, error)); ok {
		return returnFunc(ctx, owner, repo, number, opts)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, int, *github.ListOptions) []*github.RepositoryCommit); ok {
		r0 = returnFunc(ctx, owner, repo, number, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*github.RepositoryCommit)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, int, *github.ListOptions) *github.Response); ok {
		r1 = returnFunc(ctx, owner, repo, number, opts)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, string, int, *github.ListOptions) error); ok {
		r2 = returnFunc(ctx, owner, repo, number, opts)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// mockclient_listCommits_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'listCommits'
type mockclient_listCommits_Call struct {
	*mock.Call
}

// listCommits is a helper method to define mock.On call
//   - ctx context.Context
//   - owner string
//   - repo string
//   - number int
//   - opts *github.ListOptions
func (_e *mockclient_Expecter) listCommits(ctx interface{}, owner interface{}, repo interface{}, number interface{}, opts interface{}) *mockclient_listCommits_Call {
	return &mockclient_listCommits_Call{Call: _e.mock.On("listCommits", ctx, owner, repo, number, opts)}
}

func (_c *mockclient_listCommits_Call) Run(run func(ctx context.Context, owner string, repo string, number int, opts *github.ListOptions)) *mockclient_listCommits_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		var arg4 *github.ListOptions
		if args[4] != nil {
			arg4 = args[4].(*github.ListOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *mockclient_listCommits_Call) Return(repositoryCommits []*github.RepositoryCommit, response *github.Response, err error) *mockclient_listCommits_Call {
	_c.Call.Return(repositoryCommits, response, err)
	return _c
}

func (_c *mockclient_listCommits_Call) RunAndReturn(run func(ctx context.Context, owner string, repo string, number int, opts *github.ListOptions) ([]*github.RepositoryCommit, *github.Response, error)) *mockclient_listCommits_Call {
	_c.Call.Return(run)
	return _c
}

// listLabels provides a mock function for the type mockclient
func (_mock *mockclient) listLabels(ctx context.Context, owner string, repo string, opts *github.ListOptions) ([]*github.Label, *github.Response, error) {
	ret := _mock.Called(ctx, owner, repo, opts)

	if len(ret) == 0 {
		panic("no return value specified for listLabels")
	}

	var r0 []*github.Label
	var r1 *github.Response
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, *github.ListOptions) ([]*github.Label, *github.Response, error)); ok {
		return returnFunc(ctx, owner, repo, opts)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, *github.ListOptions) []*github.Label); ok {
		r0 = returnFunc(ctx, owner, repo, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*github.Label)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, *github.ListOptions) *github.Response); ok {
		r1 = returnFunc(ctx, owner, repo, opts)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, string, *github.ListOptions) error); ok {
		r2 = returnFunc(ctx, owner, repo, opts)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// mockclient_listLabels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'listLabels'
type mockclient_listLabels_Call struct {
	*mock.Call
}

// listLabels is a helper method to define mock.On call
//   - ctx context.Context
//   - owner string
//   - repo string
//   - opts *github.ListOptions
func (_e *mockclient_Expecter) listLabels(ctx interface{}, owner interface{}, repo interface{}, opts interface{}) *mockclient_listLabels_Call {
	return &mockclient_listLabels_Call{Call: _e.mock.On("listLabels", ctx, owner, repo, opts)}
}

func (_c *mockclient_listLabels_Call) Run(run func(ctx context.Context, owner string, repo string, opts *github.ListOptions)) *mockclient_listLabels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 *github.ListOptions
		if args[3] != nil {
			arg3 = args[3].(*github.ListOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *mockclient_listLabels_Call) Return(labels []*github.Label, response *github.Response, err error) *mockclient_listLabels_Call {
	_c.Call.Return(labels, response, err)
	return _c
}

func (_c *mockclient_listLabels_Call) RunAndReturn(run func(ctx context.Context, owner string, repo string, opts *github.ListOptions) ([]*github.Label, *github.Response, error)) *mockclient_listLabels_Call {
	_c.Call.Return(run)
	return _c
}

// listRepositorySecurityAdvisories provides a mock function for the type mockclient
func (_mock *mockclient) listRepositorySecurityAdvisories(ctx context.Context, owner string, repo string, opt *github.ListRepositorySecurityAdvisoriesOptions) ([]*github.SecurityAdvisory, *github.Response, error) {
	ret := _mock.Called(ctx, owner, repo, opt)

	if len(ret) == 0 {
		panic("no return value specified for listRepositorySecurityAdvisories")
	}

	var r0 []*github.SecurityAdvisory
	var r1 *github.Response
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, *github.ListRepositorySecurityAdvisoriesOptions) ([]*github.SecurityAdvisory, *github.Response, error)); ok {
		return returnFunc(ctx, owner, repo, opt)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, *github.ListRepositorySecurityAdvisoriesOptions) []*github.SecurityAdvisory); ok {
		r0 = returnFunc(ctx, owner, repo, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*github.SecurityAdvisory)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, *github.ListRepositorySecurityAdvisoriesOptions) *github.Response); ok {
		r1 = returnFunc(ctx, owner, repo, opt)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, string, *github.ListRepositorySecurityAdvisoriesOptions) error); ok {
		r2 = returnFunc(ctx, owner, repo, opt)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// mockclient_listRepositorySecurityAdvisories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'listRepositorySecurityAdvisories'
type mockclient_listRepositorySecurityAdvisories_Call struct {
	*mock.Call
}

// listRepositorySecurityAdvisories is a helper method to define mock.On call
//   - ctx context.Context
//   - owner string
//   - repo string
//   - opt *github.ListRepositorySecurityAdvisoriesOptions
func (_e *mockclient_Expecter) listRepositorySecurityAdvisories(ctx interface{}, owner interface{}, repo interface{}, opt interface{}) *mockclient_listRepositorySecurityAdvisories_Call {
	return &mockclient_listRepositorySecurityAdvisories_Call{Call: _e.mock.On("listRepositorySecurityAdvisories", ctx, owner, repo, opt)}
}

func (_c *mockclient_listRepositorySecurityAdvisories_Call) Run(run func(ctx context.Context, owner string, repo string, opt *github.ListRepositorySecurityAdvisoriesOptions)) *mockclient_listRepositorySecurityAdvisories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 *github.ListRepositorySecurityAdvisoriesOptions
		if args[3] != nil {
			arg3 = args[3].(*github.ListRepositorySecurityAdvisoriesOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *mockclient_listRepositorySecurityAdvisories_Call) Return(securityAdvisorys []*github.SecurityAdvisory, response *github.Response, err error) *mockclient_listRepositorySecurityAdvisories_Call {
	_c.Call.Return(securityAdvisorys, response, err)
	return _c
}

func (_c *mockclient_listRepositorySecurityAdvisories_Call) RunAndReturn(run func(ctx context.Context, owner string, repo string, opt *github.ListRepositorySecurityAdvisoriesOptions) ([]*github.SecurityAdvisory, *github.Response, error)) *mockclient_listRepositorySecurityAdvisories_Call {
	_c.Call.Return(run)
	return _c
}

// listWorkflowJobsAttempt provides a mock function for the type mockclient
func (_mock *mockclient) listWorkflowJobsAttempt(ctx context.Context, owner string, repo string, runID int64, attemptNumber int64, opts *github.ListOptions) (*github.Jobs, *github.Response, error) {
	ret := _mock.Called(ctx, owner, repo, runID, attemptNumber, opts)

	if len(ret) == 0 {
		panic("no return value specified for listWorkflowJobsAttempt")
	}

	var r0 *github.Jobs
	var r1 *github.Response
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, int64, int64, *github.ListOptions) (*github.Jobs, *github.Response, error)); ok {
		return returnFunc(ctx, owner, repo, runID, attemptNumber, opts)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, int64, int64, *github.ListOptions) *github.Jobs); ok {
		r0 = returnFunc(ctx, owner, repo, runID, attemptNumber, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.Jobs)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, int64, int64, *github.ListOptions) *github.Response); ok {
		r1 = returnFunc(ctx, owner, repo, runID, attemptNumber, opts)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, string, int64, int64, *github.ListOptions) error); ok {
		r2 = returnFunc(ctx, owner, repo, runID, attemptNumber, opts)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// mockclient_listWorkflowJobsAttempt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'listWorkflowJobsAttempt'
type mockclient_listWorkflowJobsAttempt_Call struct {
	*mock.Call
}

// listWorkflowJobsAttempt is a helper method to define mock.On call
//   - ctx context.Context
//   - owner string
//   - repo string
//   - runID int64
//   - attemptNumber int64
//   - opts *github.ListOptions
func (_e *mockclient_Expecter) listWorkflowJobsAttempt(ctx interface{}, owner interface{}, repo interface{}, runID interface{}, attemptNumber interface{}, opts interface{}) *mockclient_listWorkflowJobsAttempt_Call {
	return &mockclient_listWorkflowJobsAttempt_Call{Call: _e.mock.On("listWorkflowJobsAttempt", ctx, owner, repo, runID, attemptNumber, opts)}
}

func (_c *mockclient_listWorkflowJobsAttempt_Call) Run(run func(ctx context.Context, owner string, repo string, runID int64, attemptNumber int64, opts *github.ListOptions)) *mockclient_listWorkflowJobsAttempt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int64
		if args[3] != nil {
			arg3 = args[3].(int64)
		}
		var arg4 int64
		if args[4] != nil {
			arg4 = args[4].(int64)
		}
		var arg5 *github.ListOptions
		if args[5] != nil {
			arg5 = args[5].(*github.ListOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *mockclient_listWorkflowJobsAttempt_Call) Return(jobs *github.Jobs, response *github.Response, err error) *mockclient_listWorkflowJobsAttempt_Call {
	_c.Call.Return(jobs, response, err)
	return _c
}

func (_c *mockclient_listWorkflowJobsAttempt_Call) RunAndReturn(run func(ctx context.Context, owner string, repo string, runID int64, attemptNumber int64, opts *github.ListOptions) (*github.Jobs, *github.Response, error)) *mockclient_listWorkflowJobsAttempt_Call {
	_c.Call.Return(run)
	return _c
}

// repositories provides a mock function for the type mockclient
func (_mock *mockclient) repositories(ctx context.Context, owner string, repo string) (*github.Repository, *github.Response, error) {
	ret := _mock.Called(ctx, owner, repo)

	if len(ret) == 0 {
		panic("no return value specified for repositories")
	}

	var r0 *github.Repository
	var r1 *github.Response
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (*github.Repository, *github.Response, error)); ok {
		return returnFunc(ctx, owner, repo)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) *github.Repository); ok {
		r0 = returnFunc(ctx, owner, repo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.Repository)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) *github.Response); ok {
		r1 = returnFunc(ctx, owner, repo)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*github.Response)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, string) error); ok {
		r2 = returnFunc(ctx, owner, repo)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// mockclient_repositories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'repositories'
type mockclient_repositories_Call struct {
	*mock.Call
}

// repositories is a helper method to define mock.On call
//   - ctx context.Context
//   - owner string
//   - repo string
func (_e *mockclient_Expecter) repositories(ctx interface{}, owner interface{}, repo interface{}) *mockclient_repositories_Call {
	return &mockclient_repositories_Call{Call: _e.mock.On("repositories", ctx, owner, repo)}
}

func (_c *mockclient_repositories_Call) Run(run func(ctx context.Context, owner string, repo string)) *mockclient_repositories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *mockclient_repositories_Call) Return(repository *github.Repository, response *github.Response, err error) *mockclient_repositories_Call {
	_c.Call.Return(repository, response, err)
	return _c
}

func (_c *mockclient_repositories_Call) RunAndReturn(run func(ctx context.Context, owner string, repo string) (*github.Repository, *github.Response, error)) *mockclient_repositories_Call {
	_c.Call.Return(run)
	return _c
}
